/* Floating-Point types */
#include <stdio.h>
// https://en.cppreference.com/w/c/io/fprintf
// significant number (유효숫자) 유효숫자만큼 보겠다.
// 부동소수점은 Normalized significand를 사용한다
// fraction(분수) 가수부
// exponent가 모두 1이 되는 경우 혹은 모두 0이 되는 경우는 다른 용도로 사용된다.
// 수치해석학 data science machine learning graphics등을 배울 때 부동소수점에서 문제가 생기는 경우가 많다. 컴퓨터를 너무 믿으면 안된다.
// 부동소수점수는 4바이트 유효숫자가 6개밖에 안된다.
// 2^(-23) = 0.00000011921 이 숫자보다 작은 숫자의 차이는 구분하지 못한다. 즉 유효숫자 6자리 정수포함 7
// float bias 127 지수부분 -127 ~ 128
// double bias 1023 exponent -1023 ~ 1024
// gcd = greatest common divisor (최대공약수)

// bias = 3 -1.25는 2로 나눌필요 없으므로 지수부는 011, -3.5 / 2 = -1.75 한 번 나누므로 즉, -1.75 * 2^1 지수 = 1 지수부는 100(1+3)
// -1.25 = 1 011 0100 -3.50 = 1 100 1100 이걸 더한다면? 이때 지수부를 011로 맞추면 100 -> 011 지수부가 2 줄어드므로 가수부 왼쪽으로 shift
// -1.75 * 2^1 -> -3.5 * 2^0 이렇게 하겠다는 거임
// 2진수체계에서 왼쪽으로 shift? 2를 곱한다는 것
// 1 100 1.1100 -> 1 011 11.1000
// 1 100 1 1100 -> 1 011 11 1000 1.xxxx에서 1이 숨어져 있으니
// 1 011 1.0100 + 1 011 11.1000 = 1 011 100.1100 = -4.75 정규화하면 2칸 오른쪽으로 shift 지수부 2 더하기 = 1 101 1.0011 = -4.75
// 1 011 100.1100이 만약 오른쪽으로 shift하는데 버려지는 1이 있다면? 처리방법 rounding 난 몰라
// 지수를 100으로 맞추면? 허나 IEEE-754 에서는 지수부가 낮은 쪽으로 맞추는 것을 선호한다.

int main() 
{
	printf("%u\n", sizeof(float));
	printf("%u\n", sizeof(double));
	printf("%u\n", sizeof(long double));//in visual studio(msvc) double = long double, in GCC long double 12byte

	float f = 123.456;//0.0000001192 즉 소수점 6자리까지는 오차 없이 표현 가능 그렇다고 0.7f와 정확하게 같은 값을 뽑을 수 있다는 것은 아니다. 헷갈리지 마라.
	/*유효숫자가 6개인 이유*/
/*
부동소수점 형태로 저장하면 float로 저장하는 경우 4바이트 겠죠?
근데 컴퓨터에 저장될때 2진 소수로 바뀌죠? 총 32 비트겠죠?
그럼 1비트는 sign에쓰고 8비트는 지수에 쓰고 나머지 23비트를 가수에쓰겠죠?
23비트를 쓴단 말은 가수 첫 비트가 2^-1 부터 시작하니까 2^-23 까지 쓴단 말이겠죠?
그럼 오차는 어디서부터 발생할까요?
2^-24번째 비트부터 생겨나겠죠?
그럼 '최대'오차가 얼마일까요? 2^-24 X 1 + 2^-25 X 1 + 2^-26 X 1 + ... 이거겠죠?
이거 수능공부할때 많이 봤죠? 무한등비급수의 합이죠?
다 더하면 얼마에요? 2^-23 이죠?
2^-23 은 10진수로 0.0000001192 죠?
그래서 float의 정밀도가 7자리입니다(소수점이하 6자리)*/

	double d = 123.456;

	float f2 = 123.456;// warning C4305: 'initializing': truncation from 'double' to 'float'
	double d2 = 123.456f;//float size 가 double 보다 작으니 경고가 안 뜸

	int i = 3;
	float f3 = 3.f; // 3.0f라고 꼬박꼬박 적는 게 좋다.
	double d3 = 3.; // 3.0 3도 되지만 의도를 명확히

	float f4 = 1.234e10f;// E도 가능

	float f5 = 0xb.aP1f;//e대신 p를 적은 것 ex) 0x1.1p1 (0x1.1)*2^(p뒤에 숫자)=2.125000 10111.010
	double d5 = 1.0625e0;

	printf("%06.f %.70F %e %E\n", f, f, f, f); // 000123 456짤린다
	printf("%.14f %F %e %E\n", d, d, d, d);
	printf("%a %A\n", f5, f5);//%a 16진수 p꼴 출력
	printf("%a %A\n", d5, d5);//0x1.1000000000000p+0 0.0625 = 1/16

	return 0;
}
//-1.25 -7 = -8.25
//-2^0 * 1.01 -2^2 * 1.11
//-2^2 * 0.0101 -2^2 * 1.11
//-2^2 * 10.0001
//-2^3 * 1.00001
// 1000.01
//-8.25